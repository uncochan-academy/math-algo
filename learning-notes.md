# やることリスト

簡単な設定ファイルパーサーを作る
```
#interface.txt
EXPORT myFunction
IMPORT otherFunction
```
→これを読んでヘッダーファイルを自動生成するツールをつくる

複数の専門知識が組み合わさっているので一人ですべてを理解するのはむずかしい

# 既存ツール研究

- **cmake**: どうやって依存関係を解決しているのか
- **protocol buffers**: .protoファイルからコードを生成する仕組み
- **openapi generator**: yaml定義からコードを生成

# 参考書籍

- 『コンパイラ: 原理・技法・ツール』(ドラゴンブック) - パーサー理論
- 『Clean Architecture』(Robert C. Martin) - モジュール設計
- 『The Rust Programming Language』- Rust言語

# 実践プロジェクト

## 簡単なDSL (Domain-Specific Language) を作る
- 独自フォーマットのパーサー
- コード生成器

## ビルドシステムのプラグインを書く
- CMakeのカスタムコマンド
- Cargoのbuild.rs

## 小規模なモジュールシステムを実装
- 依存関係グラフの構築
- トポロジカルソート（初期化順序の決定）

# 用語集

## プログラミングパラダイム

**参照透過性**: 引数に対して同じ値（戻り値？）を返す数学よりの（プログラミングの）関数

**関数型プログラミング**: 参照透過性を重要視するプログラミング

**手続き型プログラミング**: 関数に命令や手続きを記述していくプログラミング．状態を遷移させることが基本なため，数学的な関数とは違う．

別に関数型と手続き型が排反というわけではない

**オブジェクト指向**: カプセル化・継承・ポリモーフィズム．オブジェクトという単位でモジュール化する．各オブジェクトがステートを持っている．

## ソフトウェア設計

**疎結合**: コンポーネント（クラスやモジュール）を他のコンポーネントに依存しないようにしていること．

**モジュール化**: 役割事にファイルや依存関係をシンプルにするように分割すること．分割しすぎても大変

**カプセル化**: あるデータとそれを操作する仕組みをカプセルという単位にして外から不正な操作がおこらないようにすること．データや関数にpublicとprivateをつけたりする．

**抽象化**: レイヤー化が縦なら抽象化は横．同じものを仲間でくくる

**レイヤー化**: 物理層からアプリケーション層まで機能を層にしてわかりやすくする．

**ステートマシン**: 状態とイベントと遷移の三つの要素にわけて保守性を上げること．信号でいえば青赤黄（状態）ボタンがおされた・時間がたった（イベント）信号が変わる（遷移）

**エラーハンドリング**: エラーを検出，上位モジュールに伝達，対処させること．

## ソフトウェアアーキテクチャ

**ソフトウェアアーキテクチャ**: どこになにが書いてあるかわかるようにする．コードを変更したときに他の場所でバグがでないようにする．大人数で開発するときに作業がバッティングしないようにする．などの目的で様々な手法でシステムの骨組みを考えること．がちがちにアーキテクチャを組むと初動がおそくなる．その製品を作らなくなったときに初期投資が回収できなくなることがあるから要注意．特に組み込みではチップなどの処理を高レベルの処理とわけてハードウェアに依存しないようにわける．

### アーキテクチャの要素

- **モジュール設計**: モジュールの設計
- **依存性注入**: レイヤー化するのに必要な具体的なテクニック．例えば温度センサーから情報を得たいときにA社のセンサーから読み取るコードをそのまま書くのではなく，温度をはかる窓口的なものを作りA社製センサー用のドライバーを外から注入する．これによってB社製になってもメインのアルゴリズムは変えなくてよくなる．
- **インターフェース分離**
- **publish-subscribe**

## ビルドツール・開発環境

**make/cmake**: ビルドするやつ．cmakeは異なるOSでも動くビルドするやつ．

**IDE**: integrated development environment．高機能エディタ，コンパイラ・ビルドツール・デバッガがセットになっていてソフトウェア開発が簡単になるツール．最初はideから始めて，徐々にideが自動生成したmakefileやリンカスクリプトを覗き見してカスタムしていくのがいいかもしれない

**リンカー・コンパイラ**: コンパイラは人間が書いたコードを機械語に翻訳する．しかし他のファイルで定義されているものとかはしらないからそのままでは動かないことが多い．リンカがそれらをつなぎあわせる．細かく分かれていることによって少しコード変更したときはすべてをビルドする必要がないなどメリットがある．

## パーサー・コンパイラ

**字句解析・構文解析**:字句解析でコードを単語ごとにわける．

**抽象構文木(AST)**:字句解析後の単語をabstract syntax treeはコードをコンピューターが処理しやすいように木構造にしたもの．

**最適化**:ASTをみてムダに見える計算を削る．こいつのせいで不具合がでたりしてむかつく．

**コード生成**:ASTをもとにして機械語やVerilog（高位合成）を書きだす．

rustならnom,pestなどのパーサーライブラリ

## インフラ

**コンテナ**: アプリケーションとその実行に必要な環境を一つにまとめて隔離した実行環境．

**docker**: ホストOSのカーネルを共有しアプリケーションと必要なライブラリを隔離して（コンテナ仮想化）アプリケーションを開発配置実行するオープンプラットフォーム．

## ハードウェア

**高位合成**: FPGAはハードウェア記述言語で回路をつくらなければいけないが，Cなどで書いたアルゴリズムをもとに自動で回路を作ってくれる機能．これによってハードを意識しないで済む．

**ビットストリーム**: ビットのストリーム

# ビジネスアイデア

## リーンスタートアップ

コストをそれほどかけずに最低限の製品，最低限のサービス，最低限の機能を持った試作品を短期間に作り，顧客の反応を観察する．サービスが受け入れられれば改善をほどこし機能を追加してまた提供する．

リーンとは無駄がないという意味．トヨタ生産方式のムダ取りとの共通点がある．エリックリース

### ファームウェア開発への適用例

例えばファームウェアの開発でいったら簡単な超音波センサーをハードコードやAIをがんがん使ってとりあえず動くものをつくってとりあえず売る．反応がよかったら本腰をいれる．ただしハードコードをするにしてもハードウェア抽象化層だけは作っておく．


### 設計の原則

- **特定の企業から継続的な契約をとれたらアーキテクチャを固めるなど基準を決めておく**
- **捨てる設計と残す設計を意識する**: 筐体や回路を捨ててもいいが，顧客から得られたデータやフィードバックAI学習データなどは捨てない．設計変更後も使うことを意識する
- **製造のしやすさを意識する**






雑多な追記ここから↓

ハウジング：外装のこと．ケースというべきか．筐体．タカチ電機工業が作ってる．



ソースコードの処理の流れを可視化するツール
- python tutor
- sourcetrail
- Node-RED/ComfyUI

その他ツール

- graphviz
- dependency cuisers

後で試して感想を書く

- **巡回冗長検査**:誤り検出符号の一種．お前が好きなやつ


ウォーターフォールは最初から正解が決まっているものをつくるのに強い．スケジュールやコストの予測が立てやすい．基板をたくさんつくるとか失敗が許されないシステムに向いている．完成するまでそのシステムが必要だったかがわからない．

アジャイルは開発スピードが早い．市場の変化が激しいものに対応しやすい．最終的にいくらかかるのかわかりにくい．

FPGAの回路を焼くのはコストがかかるからウォーターフォール的にやることが多い．

ファームウェアなどはノイズの処理などが実際につくるまでわからないのでアジャイル的に試行錯誤をくりかえす．

